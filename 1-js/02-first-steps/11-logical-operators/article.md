# Логічні оператори

У JavaScript існує три логічних опратори: `||` (OR), `&&` (AND), `!` (NOT).

Хоча вони називаються "логічними", вони можуть бути застосовані до значень будь-якого типу, те тільки булевих. Їх результати також може бути будь-якого типу.

Подивимось більш детально.

## || (OR)

Оператор "OR" представлений двома символами вертикальної лінії:

```js
result = a || b;
```

У класичному програмуванні логічний OR призначений для маніпулювання лише булевими значеннями. Якщо будь-який з його аргументів `true`, він повертає `true`, інакше повертає `false`.

У JavaScript оператор більш складніший і потужніший. Але спочатку подивимося, що відбувається з булевими значеннями.

Є чотири можливі логічні комбінації:

```js run
alert( true || true );   // true
alert( false || true );  // true
alert( true || false );  // true
alert( false || false ); // false
```

Як бачимо, результат завжди `true`, за винятком випадку, коли обидва операнда `false`.

Якщо операнд не є булевим, він перетворюється на логічний для обчислення.

Наприклад, число `1` розглядається як `true`, число `0` — як `false`:

```js run
if (1 || 0) { // працює так само, як ( true || false )
  alert( 'правдиво!' );
}
```

У бильшості випадків OR `||` використовується в операторі `if`, щоб перевірити, чи є *будь-яка* з заданих умов `true`.

Наприклад:

```js run
let hour = 9;

*!*
if (hour < 10 || hour > 18) {
*/!*
  alert( 'Офіс зачинений.' );
}
```

Ми можемо передавати більше умов:

```js run
let hour = 12;
let isWeekend = true;

if (hour < 10 || hour > 18 || isWeekend) {
  alert( 'Офіс зачинений.' ); // це вихідні
}
```

## OR знаходить перше правдиве значенн

Описана вище логіка дещо класична. Тепер давайте введемо "додаткові" особливості JavaScript.

Розширений алгоритм працює наступним чином.

Дано кілька значень, розділених опертором OR:

```js
result = value1 || value2 || value3;
```

Оператор OR `||` робить наступне:

- Обчислює операнди зліва направо.
- Перетворює значення кожного операнда на булеве. Якщо результат `true`, зупиняється і повертає початкове значення цього операнда.
- Якщо всі операнди були обчисленні (тобто усі були `false`), повертає останній операнд.

Значення повертається у первісному вигляді без конвертації.

Іншими словами, ланцюжок с OR `"||"` повертає перше правдиве значення або останнє, якщо не знайдено правдивого значення.

Наприклад:

```js run
alert( 1 || 0 ); // 1 (1 є правдивим)
alert( true || 'no matter what' ); // (true є правдивим)

alert( null || 1 ); // 1 (1 є першим правдивим значенням)
alert( null || 0 || 1 ); // 1 (перше правдиве значення)
alert( undefined || null || 0 ); // 0 (усі не правдиві, повертає останнє значення)
```

Це призводить до цікавого використання у порівнянни з "чистим, класичним, виключно-булевим OR".

1. **Отримання першого правдивого значення зі списку змінних або виразів.**

    Уявіть, що у нас є список змінних, які можуть містити дані убо бути `null/undefined`. Як знайти першу змінну за даними?

    Ми можемо використати OR `||`:

    ```js run
    let currentUser = null;
    let defaultUser = "Іван";

    *!*
    let name = currentUser || defaultUser || "unnamed";
    */!*

    alert( name ); // обере "Іван" – перше правдиве значення
    ```

    Якщо і `currentUser`, і `defaultUser` були б не правдивими, `"unnamed"` було б результатом.
2. **Обчислення короткого змичання.**

    Операндами можуть бути не тільки значення, але й довільні вирази. OR обчислює Цей процес називається "обчисленням короткого замикання", оскільки він іде якомога коротше зліва направо.

    Це чітко видно, коли вираз, заданий як другий аргумент, має побічний ефект, як присвоєння змінної.

    У наведеному нижче прикладі `x` не присвоюється значення:

    ```js run no-beautify
    let x;

    *!*true*/!* || (x = 1);

    alert(x); // undefined, оскільки (x = 1) не був обчислений
    ```

    Якщо замість цього перший аргумент є `false`, `||` обчислює другий, таким чином виконуючи присвоєння:

    ```js run no-beautify
    let x;

    *!*false*/!* || (x = 1);

    alert(x); // 1
    ```

    Присвоєння — це простий випадок. Можливі побічні ефекти, які не з'являтимуться, якщо обчислення не досяген їх.

    Як ми бачимо, таке використання є "більш коротким способом виконання `if`". Перший операнд перетворюється на булевий. Якщо він false, то обчислюється другий.

    У більшості випадків краще використовувати "звичайний" `if`, щоб код буле легше зрозуміти, але іноді це може бути зручно.

## && (AND)

Оператор AND представлений двома амперсандами `&&`:

```js
result = a && b;
```

У класичному програмуванні AND повертає `true`, якщо обидва оператора є правдивими і `false` у іншому випадку:

```js run
alert( true && true );   // true
alert( false && true );  // false
alert( true && false );  // false
alert( false && false ); // false
```

Приклад з `if`:

```js run
let hour = 12;
let minute = 30;

if (hour == 12 && minute == 30) {
  alert( 'Час: 12:30' );
}
```

Так само, як з OR, будь-яке значення дозволено як операнд AND:

```js run
if (1 && 0) { // оцінюється як true && false
  alert( "не буде працювати, тому що результат не правдивий" );
}
```


## AND шукає перше не правдиве значення

Дано декілька значень, об'єднаних AND:

```js
result = value1 && value2 && value3;
```

Оператор AND `&&` робить наступне:

- Обчислює операнди зліва направо.
- Перетворює кожен операнд на булевий. Якщо результат `false`, зупиняється і повертає оригінальне значення того операнда.
- Якщо всі операнди були обчисленні (тобто усі були правдиві), повертає останній операнд.

Іншими словами, AND повертає перше не правдиве значення, або останнє значення, якщо жодного не правдивого не було знайдено.

Правила, наведені вище, подібні до OR. Різниця полягає в тому, що AND повертає перше *не правдиве* значення, тоді як OR повертає перше *правдиве*.

Приклади:

```js run
// якщо перший операнд правдивий,
// AND повертає другий операнд:
alert( 1 && 0 ); // 0
alert( 1 && 5 ); // 5

// якщо перший операнд не правдивий,
// AND повертає саме його. Другий операнд ігнорується
alert( null && 5 ); // null
alert( 0 && "не важливо" ); // 0
```

Ми також можемо передавати декілька значень поспіль. Подивіться, як повертається перший не правдивий:

```js run
alert( 1 && 2 && null && 3 ); // null
```

Коли всі значення є правдивими, повертається останнє значення:

```js run
alert( 1 && 2 && 3 ); // 3, останнє
```

````smart header="Приорітет AND `&&` є більш високим за OR `||`"
Приорітет оператора AND `&&` є більш високим за OR `||`.

Отже, код `a && b || c && d` по суті є таким самим, як би вираз `&&` був у дужках: `(a && b) || (c && d)`.
````

Так само, як OR, оператор AND `&&` може іноді заміняти `if`.

Наприклад:

```js run
let x = 1;

(x > 0) && alert( 'Більше за нуль!' );
```

Дія у правій частині `&&` буде виконуватися, тільки якщо обчислення дійде до неї. Тобто, тільки якщо `(x > 0)` є ічтинним.

Тому, власне, ми маємо аналог для:

```js run
let x = 1;

if (x > 0) {
  alert( 'Більше за нуль!' );
}
```

Варіант з `&&` є коротшим. Але `if` є більш очевидним і зазвичай є більш чтабельним.

Тому ми рекомендуємо використовувати кожну конструкцію за своїм призначенням: використовуємо `if` нам потрібен if і використовуємо `&&`, якщо нам потрібен AND.

## ! (NOT)

Булевий оператор NOT представлений знаком оклику `!`.

Синтаксис дуже простий:

```js
result = !value;
```

Оператор приймає один аргумент і виконує наступне:

1. Перетворює операнд на булевий тип: `true/false`.
2. Повертає зворотне значення.

Наприклад:

```js run
alert( !true ); // false
alert( !0 ); // true
```

Подвійний NOT `!!` іноді використовується для перетворення значення у булевий тип:

```js run
alert( !!"не пустий рядок" ); // true
alert( !!null ); // false
```

Тобто, перший NOT перетворює значення на булево і повертає зворотне, а другий NOT інвертує його знову. Зрештою, ми маємо просте перетворення значення на булевий тип.

Є трохи більш детальний спосіб зробити те ж саме -- вбудована функція `Boolean`:

```js run
alert( Boolean("не пустий рядок") ); // true
alert( Boolean(null) ); // false
```

Пріоритет NOT `!` є навищим з усіх логічних операторів, тому він завжди виконується першим, перед `&&` або `||`.
