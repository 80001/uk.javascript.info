# Функціональні вирази та стрілкові функції

Для JavaScript функція -- це не "магічна мовна структура", a значення особливого ґатунку.

Синтаксис, що ми раніше використовували, називається [*Оголошення Функції*](https://developer.mozilla.org/uk/docs/Web/JavaScript/Guide/Functions#Оголошення_функції) (Function Declaration):

```js
function sayHi() {
  alert( "Привіт" );
}
```

Існує й інший синтаксис для створення функції, що називають
 [*Функціональним Виразом*](https://developer.mozilla.org/uk/docs/Web/JavaScript/Guide/Functions#Функціональні_вирази) (Function Expression).

Він виглядає так:

```js
let sayHi = function() {
  alert( "Привіт" );
};
```

У коді вище функція створюється і явно присвоюється змінній, як і будь-яке інше значення. Не важливо яким чином була визначена функція, це лише значення, що збережене в змінній `sayHi`.

Зміст обох прикладів коду однаковий: "створити функцію і покласти її значення в змінну `sayHi`".

Ми навіть можемо вивести це значення використовуючи `alert`:

```js run
function sayHi() {
  alert( "Привіт" );
}

*!*
alert( sayHi ); // показує код функції
*/!*
```

Зауважте, що останній рядок не викликає функцію тому, що після `sayHi` немає дужок. Існують мови програмування, в яких будь-яке звертання до імені функції спричиняє її виконання, але JavaScript -- не одна з них.

У JavaScript функція -- це значення, тому ми можемо поводитись з нею, як і з іншими значеннями. Код вище показує її рядкове представлення -- вихідний код.

Звичайно, функція -- особливе значення, у тому сенсі, що ми можемо здійснити її виклик за допомогою дужок: `sayHi()`.

Але це все-таки значення. Тому ми можемо працювати з нею, як і з іншими значеннями.

Скажімо, ми можемо скопіювати функцію в іншу змінну:

```js run no-beautify
function sayHi() {   // (1) створюємо
  alert( "Привіт" );
}

let func = sayHi;    // (2) копіюємо

func(); // Привіт     // (3) викликаємо копію (працює!)
sayHi(); // Привіт    //     ось так теж спрацює (а чому ні?)
```

Розглянемо детально, що тут відбулось:

1. Оголошення Функції `(1)` створює саму функцію і кладе її значення у змінну `sayHi`.
2. Рядок `(2)` копіює це значення в змінну `func`. Ще раз зауважте: після `sayHi` немає дужок. Якби вони там були, тоді `func = sayHi()` записав би *результат виклику* `sayHi()` у `func`,а не *саму функцію* `sayHi`.
3. Тепер ми можемо викликати функцію двома шляхами: `sayHi()` або `func()`.

Зауважте, що ми могли також використати Функціональний Вираз у першому рядку, щоб визначити `sayHi`:

```js
let sayHi = function() {
  alert( "Привіт" );
};

let func = sayHi;
// ...
```

Результат був би таким самим.


````smart header="Для чого потрібна крапка з комою в кінці?"
Ви можете запитати, чому Функціональний Вираз містить крапку з комою `;` в кінці, а Оголошення Функції -- ні:

```js
function sayHi() {
  // ...
}

let sayHi = function() {
  // ...
}*!*;*/!*
```

Відповідь проста:
- Нема потреби в `;` в кінці блоків коду та синтаксичних структур, що їх використовують, таких як: `if { ... }`, `for {  }`, `function f { }` тощо.
- Функціональний Вираз використаний всередині інструкції: `let sayHi = ...;` як значення. Це не окремий блок коду, а скоріше частина присвоєння. Рекомендується завжди ставити крапку з комою `;` в кінці інструкції, не зважаючи чим є значення. Отже, вживання крапки з комою не пов'язано саме з Функціональним Виразом, а лише завершує інструкцію.
````

## Колбеки (функції зворотного виклику)

Розглянемо інші приклади передачі функції як значення та використання Функціональних Виразів.

Для цього напишемо функцію `ask(question, yes, no)` з трьома параметрами:

`question`
: Текст запитання

`yes`
: Функція, що буде викликатись, якщо відповідь "Так"

`no`
: Функція, що буде викликатись, якщо відповідь "Ні"

Функція повинна поставити запитання `question` і, залежно від відповіді користувача, викликати `yes()` або `no()`:

```js run
*!*
function ask(question, yes, no) {
  if (confirm(question)) yes()
  else no();
}
*/!*

function showOk() {
  alert( "Ви погодились." );
}

function showCancel() {
  alert( "Ви скасували виконання." );
}

// використання: функції showOk, showCancel передаються як аргументи для ask
ask("Ви згодні?", showOk, showCancel);
```

Такі функції є досить практичними. Головна відмінність між функцією `ask` у реальних програмах та прикладі вище, полягає в тому, що перша може використовувати більш складні способи взаємодії з користувачем, ніж звичайний `confirm`. У браузерах така функція зазвичай показує гарненьке модальне вікно з запитанням. Але це вже інша історія.

**Аргументи `showOk` та `showCancel` функції `ask` називаються *функціями зворотного виклику* або просто *колбеками*.**

Суть полягає в тому, що ми передаємо функцію і очікуємо, що вона буде викликана (англ. "called back") пізніше, якщо це буде потрібно.
 У нашому випадку, `showOk` стає колбеком, якщо відповідь -- "yes", а `showCancel`, якщо відповідь -- "no".

Ми можемо використати Функціональний Вираз, щоб записати ту саму функцію коротше:

```js run no-beautify
function ask(question, yes, no) {
  if (confirm(question)) yes()
  else no();
}

*!*
ask(
  "Ви згодні?",
  function() { alert("Ви погодились."); },
  function() { alert("Ви скасували виконання."); }
);
*/!*
```

У цьому прикладі функції оголошені всередині виклику `ask(...)`. Вони не мають власного ім'я, тому називаються *анонімними*. До таких функцій не можна доступитись поза `ask` (бо вони не присвоєні змінним), але це саме те, що нам потрібно.

Подібний код, що з'явився в нашому скрипті є природним, в дусі JavaScript.

```smart header="Функція -- це значення, що відображає \"дію\""
Звичайні значення, як-от: рядки чи числа, відображають *дані*

Функцію, з іншого боку, можна сприймати як *дію*.

Ми можемо передавати її від змінної до змінної і викликати коли заманеться.
```


## Функціональний Вираз проти Оголошення Функції

Сформулюймо ключові відмінності між Оголошенням Функції та Функціональним Виразом.

По-перше, синтаксис: як розрізняти їх в коді.

- *Оголошення Функції:* функція оголошується окремою конструкцією "function..." в основному потоці коду.

    ```js
    // Оголошення Функції
    function sum(a, b) {
      return a + b;
    }
    ```
- *Функціональний Вираз:* функція створюється всередині іншого виразу чи синтаксичної конструкції. Нижче, створення функції відбувається в правій частині "виразу присвоєння" `=`:

    ```js
    // Функціональний Вираз
    let sum = function(a, b) {
      return a + b;
    };
    ```

Більш тонка відмінність в тому, *коли* функція буде створена рушієм Javascript.

**Функціональний Вираз буде створено тільки тоді, коли до нього дійде виконання і тільки після цього він може бути використаний.**

Щойно потік виконання досягне правої частини у присвоєнні `let sum = function…`, функцію буде створено і з цього моменту її можна буде використати (присвоїти змінній, викликати тощо ).

У випадку з Оголошенням Функції все інакше.

**Синтаксис Оголошення Функції дозволяє викликати функцію раніше ніж вона були визначена в коді**

Наприклад, глобальне Оголошення Функції буде доступним з будь-якого місця в скрипті.

Така поведінка спричинена особливостями внутрішніх алгоритмів. Коли JavaScript готується до виконання скрипта, він спочатку шукає всі глобальні Оголошення Функцій і на їх основі створює функції. Цей процес можна вважати "фазою ініціалізації".

Після того, як всі Оголошення Функцій були оброблені, рушій починає виконання коду.

Це, наприклад, буде працювати:

```js run refresh untrusted
*!*
sayHi("Микола"); // Привіт, Микола
*/!*

function sayHi(name) {
  alert( `Привіт, ${name}` );
}
```

Функцію `sayHi` було створено, коли JavaScript готувався до виконання скрипта і вона буде доступною з будь-якого місця.

...З Функціональним Виразом це не спрацювало б:

```js run refresh untrusted
*!*
sayHi("Микола"); // помилка!
*/!*

let sayHi = function(name) {  // (*) більше ніякої магії
  alert( `Привіт, ${name}` );
};
```

Створення функцій, визначених Функціональними Виразами, відбувається тоді, коли до них доходить потік виконання. Це станеться тільки при досягненні рядку з зірочкою `(*)`. Занадто пізно.

Ще однією особливістю Оголошення Функції є її блокова область видимості.

**У суворому режимі, якщо Оголошення Функції знаходиться в блоці `{...}`, то функція доступна усюди всередині блоку. Але не зовні.**

Уявімо, що нам потрібно визначити функцію `welcome()` залежно від змінної `age`, яку ми отримаємо під час виконання коду. Далі в скрипті нам буде потрібно викликати цю функцію.

Якщо ми використаємо Оголошення Функції, то це не буде працювати:

```js run
let age = prompt("Скільки вам років?", 18);

// оголошуємо функцію відповідно до умови
if (age < 18) {

  function welcome() {
    alert("Привіт!");
  }

} else {

  function welcome() {
    alert("Моє вітання!");
  }

}

// ...спробуємо викликати функцію
*!*
welcome(); // помилка в суворому режимі (ReferenceError: welcome is not defined)
*/!*
```

Це тому, що Оголошення Функції доступне тільки всередині блоку, що його містить.

Інший приклад:

```js run
let age = 16; // для прикладу присвоїмо 16

if (age < 18) {
*!*
  welcome();               // \   (виконується)
*/!*
                           //  |
  function welcome() {     //  |  
    alert("Привіт!");      //  |  Оголошення Функції доступне
  }                        //  |  усюди в блоці, що його містить
                           //  |
*!*
  welcome();               // /   (виконується)
*/!*

} else {

  function welcome() {    
    alert("Моє вітання!");
  }
}

// Тут фігурні дужки закриваються,
// тому Оголошення Функції всередині них нам не доступне

*!*
welcome(); // помилка в суворому режимі (ReferenceError: welcome is not defined)
*/!*
```

Що можна зробити, щоб функція `welcome` стала видимою поза `if`?

Правильніше було б використати Функціональний Вираз і присвоїти `welcome` змінній, що оголошена поза блоком `if` і доступна для нас.

Цей код працює як нам і потрібно:

```js run
let age = prompt("Скільки вам років?", 18);

let welcome;

if (age < 18) {

  welcome = function() {
    alert("Привіт!");
  };

} else {

  welcome = function() {
    alert("Моє вітання!");
  };

}

*!*
welcome(); // тепер все гаразд
*/!*
```

Можна спростити цей код, використавши умовний оператор `?`:

```js run
let age = prompt("Скільки вам років?", 18);

let welcome = (age < 18) ?
  function() { alert("Привіт!"); } :
  function() { alert("Моє вітання!"); };

*!*
welcome(); // спрацює
*/!*
```


```smart header="Коли використовувати Оголошення Функції, а коли Функціональний Вираз?"
Зазвичай, коли нам потрібна функція, то найперше потрібно розглянути синтаксис Оголошення Функції. Він дає нам більше свободи у тому, як організовувати код, оскільки дозволяє викликати функції ще до їх визначення.

Також функції `function f(…) {…}` простіше помітити в коді, ніж `let f = function(…) {…}`. Оголошення Функції більш легко "ловляться очима".

...Але якщо з якоїсь причини Оголошення Функції нам не підходить або нам потрібно визначити функцію згідно умови (як це було в прикладі), то слід використати Функціональний Вираз.
```


## Стрілкові функції [#arrow-functions]

Також існує ще один простіший та коротший синтаксис для створення функцій,який часто доцільніше використовувати замість Функціонального Виразу. Це так звані "стрілкові функції", а виглядають вони ось так:


```js
let func = (arg1, arg2, ...argN) => expression
```

...Цей код створить функцію `func` з аргументами `arg1..argN`, що обчислює `expression` з правого боку (використовуючи ці аргументи) та повертає його результат.

Іншими словами, це приблизно те ж саме, що і:

```js
let func = function(arg1, arg2, ...argN) {
  return expression;
};
```

...але більш лаконічно.

Розглянемо інший приклад:

```js run
let sum = (a, b) => a + b;

/* Ця стрілкова функція - це коротша форма для:

let sum = function(a, b) {
  return a + b;
};
*/

alert( sum(1, 2) ); // 3

```

Якщо функція має лише один аргумент, тоді дужки навколо параметрів можна опускати, що дозволить записати її ще коротше:

```js run
// те ж саме, що і
// let double = function(n) { return n * 2 }
*!*
let double = n => n * 2;
*/!*

alert( double(3) ); // 6
```

Якщо аргументів немає, то дужки повинні бути порожніми (але вони повинну бути):

```js run
let sayHi = () => alert("Привіт!");

sayHi();
```

Стрілкові функції можуть бути використані в той же спосіб, що й Функціональні Вирази.

Наприклад, ось переписана функція `welcome()` з попередніх прикладів:

```js run
let age = prompt("Скільки вам років?", 18);

let welcome = (age < 18) ?
  () => alert('Привіт!') :
  () => alert("Моє вітання!");

welcome(); // працює
```

Стрілкові функції можуть спершу здатись незвичними та незручними для читання, але це швидко мине, щойно очі звикнуть до таких конструкцій.

Вони дуже зручні для простих однорядкових дій, коли нам лінь писати багато букв.

```smart header="Багаторядкові стрілкові функції"

У попередніх прикладах зліва від `=>` були аргументи, а справа - окремий вираз, що певним чином їх використовував.

Проте іноді, нам потрібно дещо складніше, наприклад, декілька виразів чи інструкцій. Це також можливо, але ми повинні записати їх в фігурних дужках і використати `return`, як у звичайних функціях.

Ось так:

```js run
let sum = (a, b) => {  // фігурна дужка починає блок багаторядкової функції
  let result = a + b;
*!*
  return result; // якщо ми використовуємо фігурні дужки, то return дозволить повернути результат
*/!*
};

alert( sum(1, 2) ); // 3
```

```smart header="І ще дещо..."
Тут ми розглянули стрілкові функції як спосіб писати менше коду. Але це ще не все! Стрілкові функції мають і інші цікаві особливості. Ми повернемось до них пізніше у розділі <info:arrow-functions>.

А поки-що, ми можемо використовувати стрілкові функції для однорядкових дій та колбеків.
```

## Summary

- Functions are values. They can be assigned, copied or declared in any place of the code.
- If the function is declared as a separate statement in the main code flow, that's called a "Function Declaration".
- If the function is created as a part of an expression, it's called a "Function Expression".
- Function Declarations are processed before the code block is executed. They are visible everywhere in the block.
- Function Expressions are created when the execution flow reaches them.

In most cases when we need to declare a function, a Function Declaration is preferable, because it is visible prior to the declaration itself. That gives us more flexibility in code organization, and is usually more readable.

So we should use a Function Expression only when a Function Declaration is not fit for the task. We've seen a couple of examples of that in this chapter, and will see more in the future.

Arrow functions are handy for one-liners. They come in two flavors:

1. Without curly braces: `(...args) => expression` -- the right side is an expression: the function evaluates it and returns the result.
2. With curly braces: `(...args) => { body }` -- brackets allow us to write multiple statements inside the function, but we need an explicit `return` to return something.
