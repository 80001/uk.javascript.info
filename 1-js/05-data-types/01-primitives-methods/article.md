# Methods of primitives

JavaScript дозволяє працювати з прімітивамі (рядок, чісла, і т.д. ) так саме як з об'єктами.

Вони також надають методи для роботи. Ми вивчимо їх найближчим часом, але спочатку ми подивимось як воно працює, тому що примітиви не є об'єктами (і тут ми зробимо це ще більш зрозумілим).

Давайте розглянемо різніцю між прімітивамі та об'єктами.

Прімітив

- є Is a value of a primitive type.
- існує 6 типів примітивів: `string`, `number`, `boolean`, `symbol`, `null` and `undefined`.

Об'єкт

- можливо зберігаті декілька значень як властівості.
- може бути створений за допомогою `{}`, на приклад: `{name: "John", age: 30}`. Існує інщі об'єкті в JavaScript; функції - це теж об'єкти.

Одна з цікавіх речей щодо об'єктів полягає в тому, що ми можемо зберігати функцію як одну з його властивостей.

```js run
let john = {
  name: "John",
  sayHi: function() {
    alert("Hi buddy!");
  }
};

john.sayHi(); // Hi buddy!
```

Отже, ми створили об'єкт `john` з методом `sayHi`.

Вже існує багато вбудованих об'єктів, які працюють з датами, помилками, елементами HTML і т.д. Вони мають різні властивості і методи.

Але за все потрібно платити!

Об'єкти "важче", ніж примітиви. Вони вимагають додаткових ресурсів для підтримки внутрішньої обработки. Але, оскільки властивості і методи дуже корисні в програмуванні, двигун JavaScript намагається оптимізувати їх для зменшення додаткового навантаження.

## Примітів як об'єкт

Маємо парадокс, з яким стикається автор JavaScript:

- Є багато речей, які можна було б зробити з примітивом-рядоком або число. Було б здорово отримати доступ до цих методів.
- Примітиви повинні бути максимально швидкими та легкими.

Рішення виглядає трошкі дивно, але так і є:

1. Примітиви залишаються примітивами. Лише значення, як хотіли.
2. Мова дозволяє отримати доступ до методів та властивостей рядків, чисел, булеанів та символів.
3. Колі це трапляється, створюється спеціальний "об'єкт обгортка" з додатковою функціональністью, та потім він зніщується.

Для кожного примітиву створюється своя "обгортка": `String`, `Number`, `Boolean` та `Symbol`. Отже, вони містять різні набори методів.

Наприклад: існує метод [str.toUpperCase()](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/String/toUpperCase) якій повертає рядок з великими літерами. 

Ось як він працює:

```js run
let str = "Hello";

alert( str.toUpperCase() ); // HELLO
```

Не сладно, так? Ось що саме трапляється в `str.toUpperCase()`:

1. Рядок `str` є примітивом. Тому під час звернення до його властивості створюється спеціальний об'єкт, який знає значення рядка і має корисні методи, такі як `toUpperCase ()`.
2. Цей метод виконується і повертає новий рядок (що показує `alert`).
3. Спеціальний об'єкт руйнується, залишаючи тіки примітів `str`.

Отже примітиви можуть надавати методи, але залишаються "легкими".

Двигун JavaScript добре оптимізує цей процес. Він навіть може пропустити створення додаткового об'єкта взагалі. Але він все ще повинен дотримуватися специфікації і вести себе так, наче він її створює.

Число має свої методи, наприклад: [toFixed(n)](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/toFixed) - округлює число до заданої точності:

```js run
let n = 1.23456;

alert( n.toFixed(2) ); // 1.23
```

Ми переглянемо більш конкретні методи у розділах <info:number> та <info:string>.


````warn header="Конструктори `String/Number/Boolean` тікі для внутрішнього використання"
Деякі мови як Java дозволяють створювати "об'єкт обгортку" для примітивів явно використовуючі сінтакс як  `new Number(1)` або `new Boolean(false)`.

У JavaScript це також можливо з історичних причин, але надзвичайно **не рекомендується**. Це призведе до непередбачуваних речей.

Наприклад:

```js run
alert( typeof 1 ); // "number"

alert( typeof new Number(1) ); // "object"!
```

та завдяки тому що `zero` об'єкт, ми побачимо алерт:

```js run
let zero = new Number(0);

if (zero) { // zero є true, тому що це об'єкт
  alert( "zero is truthy?!?" );
}
```


З іншого боку, використання тих же самих функцій `String / Number / Boolean` без` new` є абсолютно розумною і корисною річчю. Вони перетворюють значення у відповідний тип: до рядка, числа або булевого (примітиву).

Наприклад, це цілком справедливо:
For example, this is entirely valid:
```js
let num = Number("123"); // convert a string to number
```
````


````warn header="null/undefined не мають методів"
Винятки становлять спеціальні примітиви `null` і `undefined`. Вони не мають відповідних "об'єктів обгортк" і не надають ніяких методів. Ми можемо назвати їх "найпримітивнішими".

Спроба доступу до властивості такого значення дасть помилку:

```js run
alert(null.test); // error
````

## Виводи

- Примітиви, крім `null` і `undefined`, дають багато корисних методів. Ми вивчимо їх у наступних розділах.
- Формально, ці методи працюють через тимчасові об'єкти, але двигун JavaScript оптимізован для швидкого виконання цих операцій, тому нам не треба хвілюватися.
