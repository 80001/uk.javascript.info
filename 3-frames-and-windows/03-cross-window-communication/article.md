# Міжвіконна комунікація

Політика "Одного походження" (Same Origin), іншими словами один й той самий сайт, вона обмежує доступ вікон і фреймів один до одного.

Ідея полягає в тому, що якщо користувач має дві відкриті сторінки: одну з `john-smith.com`, а іншу -- `gmail.com`, тоді він не хоче, щоб скрипт з `john-smith.com` читав пошту з `gmail.com`. Отже, мета політики "Одного походження" -- захистити користувачів від крадіжки даних.

## Політика "Одного походження" (Same Origin) [#same-origin]

Кажуть, що дві URL-адреси мають "одне походження", якщо вони мають однаковий протокол, домен і порт.

Усі ці URL-адреси мають одне походження:

- `http://site.com`
- `http://site.com/`
- `http://site.com/my/page.html`

А ці ні:

- <code>http://<b>www.</b>site.com</code> (інший домен: `www.` має значення)
- <code>http://<b>site.org</b></code> (інший домен: `.org` має значення)
- <code><b>https://</b>site.com</code> (інший протокол: `https`)
- <code>http://site.com:<b>8080</b></code> (інший порт: `8080`)

У політиці "Одного походження" зазначено, що:

- якщо ми маємо посилання на інше вікно, створене за допомогою `window.open` або вікно всередині `<iframe>`, і воно має те саме походження, то ми маємо повний доступ до нього.
- в іншому випадку, якщо походження відрізняється, ми не можемо отримати доступ до вмісту цього вікна: змінних, документа, будь-чого. Єдиним винятком є `location`: ми можемо змінити його (таким чином перенаправити користувача). Але ми не можемо *читати* це місцезнаходження (тому ми не можемо побачити, де зараз перебуває користувач, тому немає витоку інформації).

### iframe на практиці

Кожен `<iframe>` містить окреме вбудоване вікно з окремими об’єктами `document` та `window`.

Ми можемо отримати до них доступ за допомогою властивостей:

- `iframe.contentWindow`, щоб отримати вікно всередині `<iframe>`.
- `iframe.contentDocument`, щоб отримати документ всередині `<iframe>`, скорочення від `iframe.contentWindow.document`.

Коли ми отримуємо доступ до чогось у вбудованому вікні, браузер перевіряє, чи має iframe те саме походження. Якщо це не так, то доступ забороняється (запис у `location` є винятком, він все ще дозволений).

Наприклад, давайте спробуємо прочитати та записати в `<iframe>` з іншого походження:

```html run
<iframe src="https://example.com" id="iframe"></iframe>

<script>
  iframe.onload = function() {
    // ми можемо отримати посилання на внутрішнє вікно
*!*
    let iframeWindow = iframe.contentWindow; // OK
*/!*
    try {
      // ...але не до документа всередині нього
*!*
      let doc = iframe.contentDocument; // ПОМИЛКА
*/!*
    } catch(e) {
      alert(e); // Security Error (інше походження)
    }

    // ми також не можемо ПРОЧИТАТИ URL-адресу сторінки в iframe
    try {
      // Не вдається прочитати URL-адресу з об’єкта Location
*!*
      let href = iframe.contentWindow.location.href; // ПОМИЛКА
*/!*
    } catch(e) {
      alert(e); // Security Error
    }

    // ...ми можемо ЗАПИСАТИ в нього (і таким чином завантажувати щось інше в iframe)!
*!*
    iframe.contentWindow.location = '/'; // OK
*/!*

    iframe.onload = null; // очищаємо обробник, щоб не запускати його після зміни location
  };
</script>
```

Код вище показує помилки для будь-яких операцій, крім:

- Отримання посилання на внутрішнє вікно `iframe.contentWindow` -- це дозволено.
- Запис до `location`.

На противагу цьому, якщо `<iframe>` має те саме походження, ми можемо робити з ним що завгодно:

```html run
<!-- iframe з того ж сайту -->
<iframe src="/" id="iframe"></iframe>

<script>
  iframe.onload = function() {
    // робіть будь-що
    iframe.contentDocument.body.prepend("Привіт, світ!");
  };
</script>
```

```smart header="`iframe.onload` vs `iframe.contentWindow.onload`"
Подія `iframe.onload` (у тегу `<iframe>`) по суті така ж, як `iframe.contentWindow.onload` (у вбудованому об’єкті вікна). Вона запускається, коли вбудоване вікно повністю завантажується зі всіма ресурсами. 

...Але ми не можемо отримати доступ до `iframe.contentWindow.onload` для iframe з іншого походження, тому використовуємо `iframe.onload`.
```

## Вікна на субдоменах: document.domain

За визначенням, дві URL-адреси з різними доменами мають різне походження.

Але якщо вікна спільно використовують один домен другого рівня, наприклад, `john.site.com`, `peter.site.com` і `site.com` (тобто їхнім спільним доменом другого рівня є `site.com`), ми можемо змусити браузер ігнорувати цю різницю, щоб вони могли розглядатися як вихідні з "одного походження" для цілей міжвіконної комунікації.

Щоб це запрацювало, кожне таке вікно має запускати код:

```js
document.domain = 'site.com';
```

Це все. Тепер вони можуть взаємодіяти без обмежень. Знову ж таки, це можливо лише для сторінок з тим самим доменом другого рівня.

## Iframe: підводний камінь при роботі з document

Коли iframe походить з того самого походження, і ми можемо отримати доступ до його `document`, з’являється підводний камінь. Це не пов’язано з перехресним походженням, але важливо знати.

Після створення iframe одразу має документ. Але цей документ відрізняється від того, який до нього завантажується!

Тому, якщо ми негайно зробимо щось із документом, зміни, ймовірно, буде втрачено.

Ось подивіться:


```html run
<iframe src="/" id="iframe"></iframe>

<script>
  let oldDoc = iframe.contentDocument;
  iframe.onload = function() {
    let newDoc = iframe.contentDocument;
*!*
    // завантажений документ не збігається з початковим!
    alert(oldDoc == newDoc); // false
*/!*
  };
</script>
```

Нам не слід працювати з документом ще не завантаженого iframe, тому що це *неправильний документ*. Якщо ми встановимо для нього обробники подій, вони будуть проігноровані.

Як визначити момент, коли документ існує?

Потрібний документ безперечно знаходиться на місці, коли запускається iframe.onload. Але він запускається лише тоді, коли завантажується весь iframe з усіма ресурсами.

Ми можемо спробувати вловити момент раніше за допомогою перевірок у `setInterval`:

```html run
<iframe src="/" id="iframe"></iframe>

<script>
  let oldDoc = iframe.contentDocument;

  // кожні 100 мс перевіряйте, чи є документ новим
  let timer = setInterval(() => {
    let newDoc = iframe.contentDocument;
    if (newDoc == oldDoc) return;

    alert("Новий документ тут!");

    clearInterval(timer); // скасуйте setInterval, він більше не потрібен
  }, 100);
</script>
```

## Колекція: window.frames

Альтернативний спосіб отримати об’єкт вікна для `<iframe>` -- це отримати його з іменованої колекції `window.frames`:

- За номером: `window.frames[0]` -- об’єкт вікна для першого фрейму в документі.
- За назвою: `window.frames.iframeName` -- об’єкт вікна для фрейму з `name="iframeName"`.

Наприклад:

```html run
<iframe src="/" style="height:80px" name="win" id="iframe"></iframe>

<script>
  alert(iframe.contentWindow == frames[0]); // true
  alert(iframe.contentWindow == frames.win); // true
</script>
```

Усередині iframe можуть бути інші iframe. Відповідні об’єкти `window` утворюють ієрархію.

Навігаційні посилання:

- `window.frames` -- колекція дочірніх вікон (для вкладених фреймів).
- `window.parent` -- посилання на "батьківське" (зовнішнє) вікно.
- `window.top` -- посилання на найвище батьківське вікно.

Наприклад:

```js run
window.frames[0].parent === window; // true
```

Ми можемо використовувати властивість `top`, щоб перевірити, чи відкритий поточний документ у фреймі чи ні:

```js run
if (window == top) { // current window == window.top?
  alert('Скрипт знаходиться у верхньому вікні, а не у фреймі');
} else {
  alert('Скрипт виконується у фреймі!');
}
```

## Атрибут iframe "sandbox"

Атрибут `sandbox` дозволяє виключити певні дії всередині `<iframe>`, щоб запобігти виконанню ненадійного коду. Атрибут поміщає iframe у "пісочницю", розглядаючи його як вихідний із іншого походження та/або застосовуючи інші обмеження.

До `<iframe sandbox src="...">` застосовано "типовий набір" певних обмежень. Але їх можна послабити, якщо ми надамо розділений пробілами список обмежень, які не слід застосовувати як значення атрибута, наприклад: `<iframe sandbox="allow-forms allow-popups">`.

Іншими словами, порожній атрибут `"sandbox"` накладає найсуворіші обмеження, але ми можемо помістити розділений пробілами список тих, які ми хочемо зняти.

Ось список обмежень:

`allow-same-origin`
: Типово `"пісочниця"` нав’язує політику "іншого походження" для iframe. Іншими словами, це змушує браузер розглядати `iframe` як вихідний із іншого походження, навіть якщо його `src` вказує на той самий сайт. З усіма неявними обмеженнями для скриптів. Цей параметр видаляє цю функцію.

`allow-top-navigation`
: Дозволяє `iframe` змінити `parent.location`.

`allow-forms`
: Дозволяє надсилати форми з `iframe`.

`allow-scripts`
: Дозволяє запускати скрипти з `iframe`.

`allow-popups`
: Дозволяє `window.open` спливаючі вікна з `iframe`

Дивіться [посібник](mdn:/HTML/Element/iframe) для отримання додаткової інформації.

Наведений нижче приклад демонструє iframe із ізольованим середовищем із набором обмежень за замовчуванням: `<iframe sandbox src="...">`. Він має певний JavaScript і форму.

Зверніть увагу, що нічого не працює. Отже, типовий набір обмежень дійсно суворий:

[codetabs src="sandbox" height=140]


```smart
Мета атрибута `"sandbox"` -- лише *додати більше* обмежень. Воно не може їх видалити. Зокрема, він не може послабити обмеження щодо того самого походження, якщо iframe походить з іншого походження.
```

## Обмін повідомленнями між вікнами

Інтерфейс `postMessage` дозволяє вікнам спілкуватися один з одним незалежно від того, з якого вони походження.

Отже, це спосіб обійти політику "Одного походження". Це дозволяє вікну з `john-smith.com` спілкуватися з `gmail.com` та обмінюватися інформацією, але лише якщо вони обидва згодні та викликають відповідні функції JavaScript. Це робить його безпечним для користувачів.

Інтерфейс складається з двох частин.

### postMessage

Вікно, яке хоче надіслати повідомлення, викликає метод [postMessage](mdn:api/Window.postMessage) вікна отримання. Іншими словами, якщо ми хочемо надіслати повідомлення до `win`, ми повинні викликати `win.postMessage(data, targetOrigin)`.

Аргументи:

`data`
: Дані для відправки. Можуть бути будь-яким об’єктом, дані клонуються за допомогою "алгоритму структурованої серіалізації". IE підтримує лише рядки, тому ми повинні застосувати `JSON.stringify` для складних об’єктів для підтримки цього браузера.

`targetOrigin`
: Вказує джерело для цільового вікна, щоб повідомлення отримувало лише вікно з даного джерела.

`targetOrigin` є заходом безпеки. Пам’ятайте, якщо цільове вікно походить з іншого джерела, ми не можемо прочитати його `location` у вікні відправника. Тому ми не можемо бути впевнені, який сайт зараз відкритий у передбачуваному вікні: користувач міг би піти, а вікно відправника не має про це поняття.

Зазначення `targetOrigin` гарантує, що вікно отримає дані, лише якщо воно все ще знаходиться на потрібному сайті. Важливо, коли дані є конфіденційними.

Наприклад, тут `win` отримає повідомлення, лише якщо в ньому є документ із джерела `http://example.com`:

```html no-beautify
<iframe src="http://example.com" name="example">

<script>
  let win = window.frames.example;

  win.postMessage("повідомлення", "http://example.com");
</script>
```

Якщо ми не хочемо цієї перевірки, ми можемо встановити для `targetOrigin` значення `*`.

```html no-beautify
<iframe src="http://example.com" name="example">

<script>
  let win = window.frames.example;

*!*
  win.postMessage("повідомлення", "*");
*/!*
</script>
```


### onmessage

Щоб отримати повідомлення, цільове вікно має мати обробник події `message`. Він запускається, коли викликається `postMessage` (і перевірка `targetOrigin` успішна).

Об’єкт події має спеціальні властивості:

`data`
: Дані від `postMessage`.

`origin`
: Походження відправника, наприклад `http://javascript.info`.

`source`
: Посилання на вікно відправника. Ми можемо негайно повернути `source.postMessage(...)`, якщо хочемо.

Щоб призначити цей обробник, ми повинні використовувати `addEventListener`, короткий синтаксис `window.onmessage` не працює.

Ось приклад:

```js
window.addEventListener("message", function(event) {
  if (event.origin != 'http://javascript.info') {
    // щось із невідомого домену, проігноруємо це
    return;
  }

  alert( "отримано: " + event.data );

  // можна надіслати повідомлення назад за допомогою event.source.postMessage(...)
});
```

Повний приклад:

[codetabs src="postmessage" height=120]

## Підсумки

Щоб викликати методи та отримати доступ до вмісту іншого вікна, ми повинні спочатку мати посилання на нього.

Для спливаючих вікон у нас є такі посилання:
- З вікна відкриття: `window.open` -- відкриває нове вікно та повертає посилання на нього,
- Зі спливаючого вікна: `window.opener` -- це посилання на основне вікно зі спливаючого вікна.

Для iframes ми можемо отримати доступ до батьківських/дочірніх вікон за допомогою:
- `window.frames` -- набір вкладених об’єктів вікна,
- `window.parent`, `window.top` посилання на батьківське та верхнє вікна,
- `iframe.contentWindow` -- вікно всередині тегу `<iframe>`.

Якщо вікна мають однакове походження (хост, порт, протокол), то вони можуть робити між собою все, що захочуть.

В іншому випадку можливі лише такі дії:
- Змінити `location` іншого вікна (доступ лише для запису).
- Надіслати на нього повідомлення.

Винятки:
- Вікна, які використовують той самий домен другого рівня: `a.site.com` та `b.site.com`. Налаштування `document.domain='site.com'` в обох переведе їх у стан "одного походження".
- Якщо iframe має атрибут `sandbox`, він примусово переводиться в стан "іншого походження", якщо у значенні атрибута не вказано `allow-same-origin`. Це можна використовувати для запуску коду, якому ми не до кінця довіряємо, в iframes з того самого сайту.

Інтерфейс `postMessage` дозволяє надсилати повідомлення двом вікнам з будь-яким походженням:

1. Відправник викликає `targetWin.postMessage(data, targetOrigin)`.
2. Якщо значення у `targetOrigin` не `'*'`, тоді браузер перевіряє, чи має вікно `targetWin` джерело `targetOrigin`.
3. Якщо це так, то `targetWin` ініціює подію `message` зі спеціальними властивостями:
    - `origin` -- походження вікна відправника (наприклад, `http://my.site.com`)
    - `source` -- посилання на вікно відправника.
    - `data` -- дані, можуть бути об’єктом скрізь, крім IE (в IE тільки рядок).

    Ми повинні використовувати `addEventListener`, щоб встановити обробник для цієї події всередині вікна отримувача.
