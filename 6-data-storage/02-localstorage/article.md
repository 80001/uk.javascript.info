# LocalStorage, sessionStorage

Об'єкти веб-сховища `localStorage` та `sessionStorage` дозволяють зберігати пари ключ/значення в браузері.

Що цікаво в них, так це те, що дані зберігаються після оновлення сторінки (для `sessionStorage`) і навіть після повного перезавантаження браузера (для `localStorage`). Ми це скоро побачимо на практиці.

Ми вже маємо `cookies`. Навіщо додаткові об’єкти?

- На відміну від файлів cookie, об’єкти веб-сховища не надсилаються на сервер із кожним запитом. Завдяки цьому ми можемо зберігати набагато більше даних. Більшість браузерів дозволяють принаймні 2 мегабайти даних (або більше) і дозволяють налаштувати цей об’єм.
- Крім того, на відміну від файлів cookie, сервер не може маніпулювати об’єктами сховища через HTTP-заголовки. Все зроблено на JavaScript.
- Сховище прив’язане до джерела (домен/протокол/порт). Тобто, різні протоколи або субдомени виводять різні об’єкти зберігання, вони не можуть отримати доступ до даних один одного.

Обидва об’єкти сховища забезпечують однакові методи та властивості:

- `setItem(key, value)` -- зберегти пару ключ/значення.
- `getItem(key)` -- отримати значення за ключем.
- `removeItem(key)` -- видалити дані за ключем.
- `clear()` -- видалити все.
- `key(index)` -- отримати ключ на заданій позиції.
- `length` -- кількість збережених елементів.

Як ви можете бачити, це як колекція `Map` (`setItem/getItem/removeItem`), але також дозволяє доступ за індексом за допомогою `key(index)`.

Давайте подивимося, як це працює.

## Демо localStorage

Основними функціями `localStorage` є:

- Спільний доступ для всіх вкладок і вікон з одного джерела.
- Термін дії даних не закінчується. Дані залишаються після перезавантаження браузера і навіть перезавантаження ОС.

Наприклад, якщо ви запустите цей код...

```js run
localStorage.setItem('test', 1);
```

...І закриєте/відкриєте браузер або просто відкриєте ту саму сторінку в іншому вікні, то зможете отримати дані так:

```js run
alert( localStorage.getItem('test') ); // 1
```

Ми повинні бути лише в одному джерелі (домен/порт/протокол), шлях URL-адреси може бути різним.

`localStorage` використовується всіма вікнами з однаковим джерелом, тому якщо ми встановимо дані в одному вікні, зміна стане видимою в іншому.

## Доступ як до звичайного об’єкту

Ми також можемо використовувати простий об’єктний спосіб отримання/налаштування ключів, наприклад:

``` js run
// встановити ключ
localStorage.test = 2;

// отримати ключ
alert( localStorage.test ); // 2

// видалити ключ
delete localStorage.test;
```

Це дозволено з історичних причин і в цілому працює, але зазвичай не рекомендується, оскільки:

1. Якщо ключ створений користувачем, він може бути будь-яким, наприклад, `length` або `toString`, або іншим вбудованим методом `localStorage`. У цьому випадку `getItem/setItem` працює нормально, тоді як доступ до об'єкта не вдається:
    ``` js run
    let key = 'length';
    localStorage[key] = 5; // Помилка, не вдається призначити довжину
    ```

2. Існує подія `storage`, вона запускається, коли ми змінюємо дані. Ця подія не відбувається при зміні даних без виклику `setItem`. Ми побачимо це пізніше в цьому розділі.

## Перебирання ключів

Як ми бачили, методи забезпечують функцію «отримати/встановити/видалити за ключем». Але як отримати всі збережені значення чи ключі?

На жаль, об’єкти зберігання не є ітераційними.

Один із способів - маніпулювати ними як з масивом:

```js run
for(let i=0; i<localStorage.length; i++) {
  let key = localStorage.key(i);
  alert(`${key}: ${localStorage.getItem(key)}`);
}
```

Інший спосіб — використовувати цикл `for key in localStorage`, так само, як ми робимо зі звичайними об'єктами.

Він перебирає ключі, але також виводить кілька вбудованих полів, які нам не потрібні:

```js run
// погана спроба
for(let key in localStorage) {
  alert(key); // показує getItem, setItem та інші вбудовані елементи
}
```

...Тож нам потрібно або відфільтрувати поля з прототипу за допомогою перевірки `hasOwnProperty`:

```js run
for(let key in localStorage) {
  if (!localStorage.hasOwnProperty(key)) {
    continue; // пропускати ключі, такі як "setItem", "getItem" тощо
  }
  alert(`${key}: ${localStorage.getItem(key)}`);
}
```

...Або просто отримати «власні» ключі за допомогою `Object.keys`, а потім переглянути їх, якщо потрібно:

```js run
let keys = Object.keys(localStorage);
for(let key of keys) {
  alert(`${key}: ${localStorage.getItem(key)}`);
}
```

Останній варіант працює, оскільки `Object.keys` повертає лише ключі, які належать об’єкту, ігноруючи прототип.


## Тільки рядки

Зверніть увагу, що і ключ, і значення мають бути рядками.

Якби був будь-який інший тип, наприклад число або об’єкт, він автоматично перетворився б на рядок:

```js run
localStorage.user = {name: "John"};
alert(localStorage.user); // [object Object]
```

Однак ми можемо використовувати `JSON` для зберігання об'єктів:

``` js run
localStorage.user = JSON.stringify({name: "Тарас"});

// через деякий час
let user = JSON.parse( localStorage.user );
alert( user.name ); // Тарас
```

Також можна об’єднати весь об’єкт сховища в рядки, наприклад, для цілей налагодження:

``` js run
// додано параметри форматування до JSON.stringify, щоб об'єкт виглядав краще
alert( JSON.stringify(localStorage, null, 2) );
```


## sessionStorage

Об'єкт `sessionStorage` використовується набагато рідше, ніж `localStorage`.

Властивості та методи ті самі, але набагато більш обмежені:

- `sessionStorage` існує лише на поточній вкладці браузера.
  - Інша вкладка з тією ж сторінкою матиме інше сховище.
  - Але він використовується між iframes на одній вкладці (за умови, що вони походять з одного джерела).
- Дані зберігаються після оновлення сторінки, але не закриття/відкриття вкладки.

Давайте подивимося на це в дії.

Запустіть цей код...

```js run
sessionStorage.setItem('test', 1);
```

...Тоді оновіть сторінку. Тепер ви все ще можете отримати дані:

``` js run
alert( sessionStorage.getItem('test') ); // після оновлення: 1
```

...Але якщо ви відкриєте ту саму сторінку в іншій вкладці та спробуєте там ще раз, код вище поверне `null`, що означає "нічого не знайдено".

Це саме тому, що `sessionStorage` прив’язаний не лише до джерела, а й до вкладки браузера. З цієї причини `sessionStorage` використовується не часто.

## Подія Storage

Коли дані оновлюються в `localStorage` або `sessionStorage`, запускається подія [storage](https://www.w3.org/TR/webstorage/#the-storage-event) із властивостями:

- `key` – ключ, який було змінено (`null`, якщо викликається `.clear()`).
- `oldValue` – старе значення (`null`, якщо ключ додано знову).
- `newValue` – нове значення (`null`, якщо ключ видалено).
- `url` – URL-адреса документа, де відбулося оновлення.
- `storageArea` – об'єкт `localStorage` або `sessionStorage`, де відбулося оновлення.

Важливо: подія запускається на всіх об’єктах `window`, де доступне сховище, крім того, що його викликало.

Давайте детальніше.

Уявіть, у вас є два вікна з однаковим сайтом у кожному. Таким чином, `localStorage` є спільним між ними.

```online
Ви можете відкрити цю сторінку в двох вікнах браузера, щоб перевірити наведений нижче код.
```

Якщо обидва вікна прослуховують `window.onstorage`, то кожне з них реагуватиме на оновлення, які відбулися в іншому.

```js run
// запускає оновлення, створені в тому самому сховищі з інших документів
window.onstorage = event => { // також можна використовувати window.addEventListener('storage', event => {
  if (event.key != 'зараз') return;
  alert(event.key + ':' + event.newValue + " в " + event.url);
};

localStorage.setItem('зараз', ​​Date.now());
```

Зверніть увагу, що подія також містить: `event.url` -- URL-адресу документа, в якому оновлено дані.

Крім того, `event.storageArea` містить об'єкт сховища -- подія однакова для `sessionStorage` та `localStorage`, тому `event.storageArea` посилається на той, який було змінено. Ми навіть можемо захотіти щось змінити в ньому, «відреагувати» на зміни.

**Це дозволяє різним вікнам з одного джерела обмінюватися повідомленнями.**

Сучасні браузери також підтримують [Broadcast channel API](mdn:/api/Broadcast_Channel_API), спеціальний API для міжвіконного зв’язку одного джерела, він більш повнофункціональний, але менш підтримується. Існують бібліотеки, які багаторазово заповнюють цей API на основі `localStorage`, що робить його доступним скрізь.

## Висновки

Об’єкти веб-сховища `localStorage` та `sessionStorage` дозволяють зберігати ключ/значення в браузері.
- І `key`, і `value` мають бути рядками.
- Ліміт становить 5 Мб+, залежить від браузера.
— Дані не мають "терміну дії", тобто не видаляються.
- Дані прив'язані до джерела (домен/порт/протокол).

| `localStorage` | `sessionStorage` |
|----------------|------------------|
| Спільний для всіх вкладок і вікон з однаковим джерелом | Відображається на вкладці браузера, включаючи iframe з того самого джерела |
| Не видаляється при перезапуску браузера | Витримує оновлення сторінки (але не закриття вкладки) |

API:

- `setItem(key, value)` -- зберегти пару ключ/значення.
- `getItem(key)` -- отримати значення за ключем.
- `removeItem(key)` -- видалити дані за ключем.
- `clear()` -- видалити все.
- `key(index)` -- отримати ключ на заданій позиції.
- `length` -- кількість збережених елементів.
- Використовуйте `Object.keys`, щоб отримати всі ключі.
- Ми маємо доступ до ключів як властивостей об'єкта та можемо з ними маніпулювати, у цьому випадку подія `storage` не ініціюється.

Подія storage:

- Спрацьовує на виклики `setItem`, `removeItem`, `clear`.
- Містить усі дані про операцію (`key/oldValue/newValue`), URL-адресу документа та об'єкт сховища `storageArea`.
- Спрацьовує для всіх об’єктів `window`, які мають доступ до сховища, крім того, який його створив (у межах вкладки для `sessionStorage`, глобально для `localStorage`).
